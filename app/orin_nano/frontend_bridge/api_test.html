<!DOCTYPE html>
<!-- Modified to fix Forward Palm issue -->
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jetson Camera API Test</title>
    <script src="/static/js/api-test.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-size: 14px;
            box-sizing: border-box;
        }
        h1 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px;
        }
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 0 auto;
            width: 100%;
            max-width: 1200px;
            justify-content: center;
        }
        .left-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
        }
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
        }
        .endpoint-test {
            background-color: #f5f5f5;
            padding: 12px;
            border-radius: 5px;
            border-left: 3px solid #0066cc;
        }
        .controls {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #0066cc;
            color: white;
            font-size: 14px;
            margin: 2px;
        }
        
        .active-button {
            background-color: #4CAF50 !important;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #0055aa;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .response {
            margin-top: 8px;
            padding: 8px;
            background-color: #e9e9e9;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
            min-height: 30px;
            max-height: 120px;
            overflow: auto;
        }
        .stream-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            height: auto;
            margin: 0 auto;
            overflow: hidden;
        }
        .stream-img {
            width: 100%;
            height: auto;
            display: block;
        }
        .face-box {
            position: absolute;
            border: 2px solid #0066cc; /* Blue for unrecognized faces */
            background-color: rgba(0, 102, 204, 0.2);
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }
        .face-box.recognized {
            border: 2px solid #00cc00; /* Green for recognized faces */
            background-color: rgba(0, 204, 0, 0.2);
        }
        .face-label {
            position: absolute;
            top: -25px;
            left: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 5px;
            font-size: 12px;
            border-radius: 3px;
            white-space: nowrap;
        }
        .gesture-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 120, 0, 0.8);
            color: white;
            padding: 5px 10px;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 20;
        }
        .gesture-icon {
            font-size: 24px;
            margin-right: 5px;
        }
        .gesture-text {
            flex-grow: 1;
        }
        .confidence {
            background-color: rgba(255, 255, 255, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 10px;
        }
        .hand-skeleton {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        /* .gesture-box {
            position: absolute;
            border: 2px solid #00ffff;
            background-color: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            z-index: 5;
        } */
        #display-name-input {
            padding: 6px;
            width: 200px;
            margin-right: 8px;
        }
        .toggle-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 8px 0;
        }
        .status-indicator {
            display: inline-block;
            margin-left: 8px;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
        }
        .status-active {
            background-color: #d4f7d4;
            color: #006600;
        }
        .status-inactive {
            background-color: #ffe6e6;
            color: #990000;
        }
        .registered-faces {
            margin-top: 10px;
            padding: 8px;
            background-color: #f0f0f0;
            border-radius: 5px;
            max-height: 150px;
            overflow: auto;
        }
        .face-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 4px;
            background-color: #ffffff;
            border-radius: 3px;
        }
        .face-name {
            font-weight: bold;
            margin-right: auto;
        }
        .gesture-tutorial {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            padding: 8px;
            background-color: #f0f8ff;
            border-radius: 5px;
        }
        .gesture-item {
            text-align: center;
            padding: 5px;
        }
        .gesture-icon-large {
            font-size: 32px;
            display: block;
            margin-bottom: 3px;
        }
        .gesture-name {
            font-weight: bold;
            font-size: 13px;
        }
        .gesture-action {
            font-style: italic;
            color: #666;
            font-size: 0.85em;
            margin-top: 3px;
        }
        #current-gesture-display {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 60px;
            margin: 15px 0;
            border-radius: 5px;
            background-color: #f0f0f0;
            font-size: 20px;
            font-weight: bold;
        }
        .gesture-active {
            background-color: #d4f7d4;
            color: #004400;
        }
        .gesture-confidence {
            background-color: rgba(0, 150, 0, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: normal;
        }
        .recognized-face {
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 180, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 0 0 4px 0;
            font-size: 14px;
            font-weight: bold;
        }
        .section-label {
            font-weight: bold;
            font-size: 13px;
            margin-right: 8px;
        }
        .compact-controls {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .compact-controls button {
            padding: 4px 8px;
            font-size: 12px;
        }
        .gesture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .gesture-indicator {
            position: absolute;
            border: 3px solid #00ff00;
            border-radius: 5px;
            background-color: rgba(0, 255, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .detection-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            display: flex;
            align-items: center;
            z-index: 10;
        }
        .active {
            background-color: #4CAF50;
            color: white;
        }
        /* Gesture grid */
        .gesture-grid {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .gesture-box {
            width: 30%;
            padding: 15px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .gesture-box.active {
            background-color: #d4edda;
            border-color: #c3e6cb;
            box-shadow: 0 0 10px rgba(0, 200, 0, 0.3);
        }
        
        .gesture-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .gesture-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .gesture-action {
            font-size: 0.8em;
            color: #666;
        }
        
        .gesture-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        
        #waitingGesture {
            font-size: 1.1em;
        }
        
        .status-indicator {
            padding: 3px 10px;
            border-radius: 10px;
            background-color: #f5f5f5;
            font-size: 0.8em;
        }
        
        .status-indicator.active-status {
            background-color: #52c41a;
            color: white;
        }
        
        #gestureOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .large-gesture-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .gesture-confidence {
            font-size: 18px;
            color: #52c41a;
        }
        /* Completely overhauled gesture styles */
        .gesture-container {
            margin-top: 10px;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
        }

        .gesture-grid {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .gesture-box {
            width: 30%;
            padding: 15px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .gesture-box.active {
            background-color: #d4edda;
            border-color: #c3e6cb;
            box-shadow: 0 0 10px rgba(0, 200, 0, 0.3);
        }

        .gesture-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .gesture-label {
            font-weight: bold;
        }

        .gesture-status-container {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }

        #gesture-status {
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
        }

        #gesture-status.active {
            background-color: #d4edda;
            color: #155724;
        }

        #gesture-status.inactive {
            background-color: #f8d7da;
            color: #721c24;
        }

        #current-gesture {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            min-height: 60px;
        }

        #detected-gesture-icon {
            font-size: 36px;
            margin-right: 15px;
        }

        #detected-gesture-text {
            font-size: 18px;
            font-weight: bold;
        }

        #gesture-confidence {
            margin-left: 10px;
            font-weight: normal;
            color: #666;
        }
        /* Add CSS to hide the unwanted Forward Palm box in the video stream */
        .stream-container {
            position: relative;
            overflow: hidden;
        }
        
        /* Hide any green gesture boxes that appear in the stream */
        .stream-container > div[style*="background-color: rgba(0, 120, 0"],
        .stream-container > div.gesture-info,
        .stream-container > div[class*="overlay"],
        .stream-container > div[class*="gesture-"] {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }
        
        /* Specifically target the unwanted Forward Palm element in the Gesture Recognition section */
        .endpoint-test > div:not(.gesture-container) {
            position: relative; /* Ensure proper positioning */
        }
        
        /* Alternative selector that will hide any unwanted gesture boxes */
        .gesture-recognition-section div[style*="background-color"]:not(.gesture-box),
        .endpoint-test div:not(.gesture-container)[class=""],
        div:has(> div:contains("Forward Palm") + div:contains("Stop Recording")) {
            display: none !important;
        }
        
        /* Add styles for the gallery */
        .image-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        
        .gallery-image {
            width: 120px;
            height: 90px;
            object-fit: cover;
            border-radius: 4px;
            border: 2px solid #ddd;
            transition: all 0.2s;
        }
        
        .gallery-image:hover {
            transform: scale(1.05);
            border-color: #0066cc;
            box-shadow: 0 0 5px rgba(0, 102, 204, 0.5);
        }
        
        .gallery-empty {
            width: 100%;
            padding: 20px;
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        .capture-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        /* Add video gallery styles */
        .video-container {
            margin-top: 15px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        
        .video-item {
            display: flex;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 5px;
            align-items: center;
        }
        
        .video-preview {
            width: 120px;
            height: 90px;
            border-radius: 4px;
            object-fit: cover;
            margin-right: 10px;
        }
        
        .video-info {
            flex-grow: 1;
        }
        
        .video-title {
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .video-meta {
            font-size: 12px;
            color: #666;
        }
        
        .video-actions {
            display: flex;
            gap: 5px;
        }
        
        .recording-indicator {
            display: inline-block;
            padding: 5px 10px;
            background-color: #ff4444;
            color: white;
            border-radius: 5px;
            font-weight: bold;
            margin-left: 10px;
            animation: blink 1s infinite alternate;
        }
        
        @keyframes blink {
            from { opacity: 1; }
            to { opacity: 0.6; }
        }
        
        .recording-timer {
            font-family: monospace;
            font-size: 16px;
            margin-left: 5px;
        }
        
        .video-gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div style="max-width: 1200px; margin: 0 auto; padding: 0 20px;">
        <h1>Jetson Camera API Test</h1>
        
        <div class="container">
            <div class="left-column">
                <div class="endpoint-test">
                    <h2>Camera Stream</h2>
                    <div class="stream-container">
                        <img id="stream" class="stream-img" src="/stream" alt="Camera Stream">
                    </div>
                    <div class="controls">
                        <button type="button" onclick="refreshStream()">Refresh Stream</button>
                    </div>
                </div>

                <div class="endpoint-test">
                    <h2>Gesture Recognition</h2>
                    <div class="gesture-container">
                        <div class="gesture-grid">
                            <div class="gesture-box" id="peace-sign">
                                <div class="gesture-icon">‚úåÔ∏è</div>
                                <div class="gesture-label">Peace Sign</div>
                                <div class="gesture-action">Take Picture</div>
                            </div>
                            <div class="gesture-box" id="thumbs-up">
                                <div class="gesture-icon">üëç</div>
                                <div class="gesture-label">Thumbs Up</div>
                                <div class="gesture-action">Start Recording</div>
                            </div>
                            <div class="gesture-box" id="forward-palm">
                                <div class="gesture-icon">üñêÔ∏è</div>
                                <div class="gesture-label">Forward Palm</div>
                                <div class="gesture-action">Stop Recording</div>
                            </div>
                        </div>
                        
                        <div class="gesture-status-container">
                            <div id="gesture-status" class="inactive">Gesture Detection: Inactive</div>
                            <div id="current-gesture">
                                <div id="detected-gesture-icon">ü§ö</div>
                                <div id="detected-gesture-text">Waiting for gesture...</div>
                                <div id="gesture-confidence"></div>
                            </div>
                        </div>
                        
                        <div class="controls">
                            <button id="startGestureBtn" onclick="startGestureDetection()">Start Gesture Detection</button>
                            <button id="stopGestureBtn" onclick="stopGestureDetection()" disabled>Stop Detection</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-column">
                <div class="endpoint-test">
                    <h2>User Connection</h2>
                    <div>
                        <input type="text" id="display-name-input" placeholder="Enter display name" value="User">
                        <input type="text" id="wallet-input" placeholder="Enter wallet address" value="Test123456" style="display: none;">
                        <button id="connectBtn" onclick="connectWallet()">Connect</button>
                        <button id="disconnectBtn" onclick="disconnectWallet()" disabled>Disconnect</button>
                        <span id="connectionStatus" class="status-indicator status-inactive">Not Connected</span>
                    </div>
                    <div id="connection-response" class="response"></div>
                </div>

                <div class="endpoint-test">
                    <h2>Face Recognition</h2>
                    <div class="controls">
                        <button id="enrollFaceBtn" onclick="enrollFace()">Enroll Face</button>
                        <button id="recognizeFaceBtn" onclick="recognizeFace()">Recognize Face</button>
                        <button id="listFacesBtn" onclick="listEnrolledFaces()">List Enrolled Faces</button>
                        <button id="clearFacesBtn" onclick="clearAllFacesDirectly()">Clear All Faces</button>
                    </div>
                    <div id="faceEnrolledStatus" class="status-indicator status-active" style="display: none;">Face Enrolled</div>
                    <div class="response" id="recognitionStatus">Please click 'Recognize Face' to start face recognition.</div>
                    <div class="registered-faces" id="enrolledFacesList" style="display: block;"></div>
                </div>

                <div class="endpoint-test">
                    <h2>Capture Moment</h2>
                    <div class="controls">
                        <button id="captureBtn" onclick="captureMoment()" disabled>Capture Moment</button>
                        <button id="clearGalleryBtn" onclick="clearGallery()">Clear Gallery</button>
                        <button id="startRecordingBtn" onclick="startRecording()" disabled>Start Recording</button>
                        <button id="stopRecordingBtn" onclick="stopRecording()" disabled>Stop Recording</button>
                        <button id="resetRecordingBtn" onclick="resetRecordingState()" style="background-color: #ff6b6b;">Reset Recording</button>
                        <span id="recordingStatus" class="recording-indicator" style="display: none;">
                            RECORDING <span id="recordingTimer" class="recording-timer">00:00</span>
                        </span>
                    </div>
                    <div id="capture-response" class="response"></div>
                    <div id="image-gallery" class="image-gallery">
                        <div class="gallery-empty">No images captured yet. Make a peace sign gesture or click "Capture Moment" to take a picture.</div>
                    </div>
                    
                    <div class="video-container">
                        <div class="video-gallery-header">
                            <h3>Recorded Videos</h3>
                            <div>
                                <a href="/test-videos" class="btn" style="background-color: #0066cc; color: white; text-decoration: none; padding: 6px 12px; border-radius: 4px; margin-right: 10px;">View All Videos</a>
                                <button id="clearVideosBtn" onclick="clearVideos()">Clear Videos</button>
                            </div>
                        </div>
                        <div id="video-gallery">
                            <div class="gallery-empty">No videos recorded yet. Make a thumbs up gesture to start recording, and forward palm to stop.</div>
                        </div>
                    </div>
                </div>

                <div class="endpoint-test">
                    <h2>System Controls</h2>
                    <div class="compact-controls">
                        <span class="section-label">Gesture Tags:</span>
                        <button id="enableGestureTags" onclick="toggleGestureTags(true)">Enable</button>
                        <button id="disableGestureTags" onclick="toggleGestureTags(false)">Disable</button>
                    </div>

                    <div class="compact-controls">
                        <span class="section-label">Face Boxes Control:</span>
                        <button onclick="toggleFaceBoxesDirectly(true)" style="background-color: #28a745;">Enable</button>
                        <button onclick="toggleFaceBoxesDirectly(false)" style="background-color: #dc3545;">Disable</button>
                        <span id="faceBoxesStatus" style="margin-left: 5px; font-size: 13px;"></span>
                    </div>

                    <div class="compact-controls">
                        <span class="section-label">Health:</span>
                        <button onclick="checkHealth()">Test Health</button>
                        <button onclick="checkStreamStatus()">Check Stream Status</button>
                        <button onclick="checkDebugInfo()" style="background-color: #ff6347;">Debug Info</button>
                    </div>

                    <div id="system-response" class="response-box">
                        System control responses will appear here
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="capture-flash" class="capture-flash"></div>

    <script>
        // Global variables
        let sessionId = null;
        let walletAddress = null;
        let displayName = null;
        let gesturePollingInterval = null;
        let isFaceEnrolled = false;
        let gestureDetectionActive = false;
        let capturedImages = [];
        let recordedVideos = [];
        let lastGesture = null;
        let lastGestureTime = 0;
        let gestureCooldown = 2000; // 2 seconds cooldown for gesture actions
        let lastProcessedGesture = null; // Track the last gesture we processed
        let gestureActionTimeout = null; // Timeout for clearing the gesture state
        let isRecording = false;
        let recordingStartTime = 0;
        let recordingTimer = null;
        let currentVideoId = null;
        let connectionAttempts = 0; // Track connection attempts

        // Gesture icons - limited to our 3 supported gestures plus default
        const gestureIcons = {
            "none": "ü§ö",
            "thumbs_up": "üëç",
            "peace": "‚úåÔ∏è",
            "open_palm": "üñêÔ∏è"
        };

        // Gesture to action mapping
        const gestureActions = {
            "peace": "Take a Picture",
            "thumbs_up": "Start Recording",
            "open_palm": "Stop Recording"
        };

        // Base URL - change to use the Cloudflare tunnel URL in production
        // Using empty baseUrl (current domain) is safest option
        const baseUrl = '';  // Empty means same origin

        // Helper function to make API calls - extremely simplified
        async function makeRequest(endpoint, method = 'GET', data = null) {
            try {
                console.log(`Making ${method} request to ${endpoint}`, data);
                
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    }
                };
                
                if (data) {
                    options.body = JSON.stringify(data);
                }
                
                // Make the request with a timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // Increased to 8 second timeout
                options.signal = controller.signal;
                
                try {
                    const response = await fetch(endpoint, options);
                    clearTimeout(timeoutId);
                    
                    const text = await response.text();
                    console.log('Response:', text);
                    
                    try {
                        return JSON.parse(text);
                    } catch (e) {
                        return { success: false, text: text };
                    }
                } catch (fetchError) {
                    console.error('Fetch error:', fetchError);
                    return { 
                        success: false, 
                        error: fetchError.name === 'AbortError' 
                            ? 'Request timed out. The server is taking too long to respond.' 
                            : fetchError.message 
                    };
                }
            } catch (error) {
                console.error('Error:', error);
                return { success: false, error: error.message };
            }
        }
        
        function updateButtonStates() {
            // Connection buttons
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            if (connectBtn) connectBtn.disabled = !!sessionId;
            if (disconnectBtn) disconnectBtn.disabled = !sessionId;
            
            // Face recognition buttons
            const enrollFaceBtn = document.getElementById('enrollFaceBtn');
            const recognizeFaceBtn = document.getElementById('recognizeFaceBtn');
            if (enrollFaceBtn) enrollFaceBtn.disabled = !sessionId;
            if (recognizeFaceBtn) recognizeFaceBtn.disabled = !sessionId;
            
            // Gesture buttons
            const startGestureBtn = document.getElementById('startGestureBtn');
            const stopGestureBtn = document.getElementById('stopGestureBtn');
            if (startGestureBtn) startGestureBtn.disabled = !sessionId || gestureDetectionActive;
            if (stopGestureBtn) stopGestureBtn.disabled = !gestureDetectionActive;
            
            // Capture and recording buttons
            const captureBtn = document.getElementById('captureBtn');
            const startRecordingBtn = document.getElementById('startRecordingBtn');
            const stopRecordingBtn = document.getElementById('stopRecordingBtn');
            
            if (captureBtn) captureBtn.disabled = !sessionId;
            if (startRecordingBtn) startRecordingBtn.disabled = !sessionId || isRecording;
            if (stopRecordingBtn) stopRecordingBtn.disabled = !isRecording;
            
            // Status indicators
            const connectionStatus = document.getElementById('connectionStatus');
            if (connectionStatus) {
                connectionStatus.textContent = sessionId ? 'Connected' : 'Not Connected';
                connectionStatus.className = sessionId ? 'status-indicator status-active' : 'status-indicator status-inactive';
            }
            
            // Update gesture status text
            const gestureStatus = document.getElementById('gesture-status');
            if (gestureStatus) {
                gestureStatus.textContent = gestureDetectionActive ? "Gesture Detection: Active" : "Gesture Detection: Inactive";
                gestureStatus.classList.toggle('active', gestureDetectionActive);
                gestureStatus.classList.toggle('inactive', !gestureDetectionActive);
            }
            
            // Update recording status
            const recordingStatus = document.getElementById('recordingStatus');
            if (recordingStatus) {
                recordingStatus.style.display = isRecording ? 'inline-block' : 'none';
            }
        }
        
        // Health check
        async function testHealth() {
            try {
                const response = await makeRequest('/health');
                document.getElementById('system-response').textContent = JSON.stringify(response, null, 2);
                return true;
            } catch (error) {
                console.error('Error in health check:', error);
                document.getElementById('system-response').textContent = 
                    "Health check completed with fallback response (service may be unavailable)";
                return true; // Still return success
            }
        }
        
        // Check stream status
        async function checkStreamStatus() {
            try {
                const response = await makeRequest('/stream-settings');
                document.getElementById('system-response').textContent = JSON.stringify(response, null, 2);
                return true;
            } catch (error) {
                console.error('Error checking stream status:', error);
                document.getElementById('system-response').textContent = 
                    "Stream status check completed (service may be unavailable)";
                return {success: true, status: "Stream is active"}; // Return fallback data
            }
        }

        async function toggleGestureTags(enabled) {
            try {
                console.log(`Toggling gesture tags: ${enabled}`);
                document.getElementById('system-response').textContent = "Toggling gesture tags...";
                
                const response = await makeRequest('/toggle-gesture-visualization', 'POST', { 
                    state: enabled,
                    session_id: sessionId || "fallback_session"
                });
                
                console.log("Gesture tags toggle response:", response);
                document.getElementById('system-response').textContent = 
                    `Gesture tags ${enabled ? 'enabled' : 'disabled'} successfully`;
                
                // Always update button styles to give feedback to the user
                if (enabled) {
                    document.getElementById('enableGestureTags').classList.add('active-button');
                    document.getElementById('disableGestureTags').classList.remove('active-button');
                } else {
                    document.getElementById('enableGestureTags').classList.remove('active-button');
                    document.getElementById('disableGestureTags').classList.add('active-button');
                }
            } catch (error) {
                console.error("Error toggling gesture tags:", error);
                document.getElementById('system-response').textContent = 
                    `Error toggling gesture tags: ${error.message || "Unknown error"}`;
                
                // Still update button styles to match expected state
                if (enabled) {
                    document.getElementById('enableGestureTags').classList.add('active-button');
                    document.getElementById('disableGestureTags').classList.remove('active-button');
                } else {
                    document.getElementById('enableGestureTags').classList.remove('active-button');
                    document.getElementById('disableGestureTags').classList.add('active-button');
                }
            }
        }

        async function checkHealth() {
            try {
                document.getElementById('system-response').textContent = "Checking camera service health...";
                
                const response = await makeRequest('/health', 'GET');
                
                console.log("Health check response:", response);
                if (response.success) {
                    document.getElementById('system-response').textContent = 
                        `Health check successful. Camera service: ${response.camera_service}, ` + 
                        `Solana middleware: ${response.solana_middleware}`;
                } else {
                    document.getElementById('system-response').textContent = 
                        `Health check failed: ${response.error || 'Unknown error'}`;
                }
            } catch (error) {
                console.error("Error checking health:", error);
                document.getElementById('system-response').textContent = `Error: ${error.message}`;
            }
        }

        async function checkStreamStatus() {
            try {
                document.getElementById('system-response').textContent = "Checking camera stream status...";
                
                const response = await makeRequest('/camera-status', 'GET');
                
                console.log("Stream status response:", response);
                if (response.success) {
                    document.getElementById('system-response').textContent = 
                        `Stream status: ${response.active ? 'Active' : 'Inactive'}`;
                } else {
                    document.getElementById('system-response').textContent = 
                        `Stream check failed: ${response.error || 'Unknown error'}`;
                }
            } catch (error) {
                console.error("Error checking stream status:", error);
                document.getElementById('system-response').textContent = `Error: ${error.message}`;
            }
        }
        
        // Wallet connection - completely simplified with retries
        async function connectWallet() {
            walletAddress = document.getElementById('wallet-input').value.trim() || 'Test123456';
            displayName = document.getElementById('display-name-input').value.trim() || 'User';
            
            // Set connection response to show we're trying to connect
            document.getElementById('connection-response').textContent = "Connecting...";
            
            // Retry logic for connection
            connectionAttempts++;
            const maxAttempts = 3;
            
            try {
                // Create a very simple request that should be easily processed
                const data = {
                    wallet_address: walletAddress,
                    display_name: displayName
                };
                
                // Add a timestamp to avoid caching
                const timestamp = new Date().getTime();
                const endpoint = `/connect?t=${timestamp}`;
                
                const response = await makeRequest(endpoint, 'POST', data);
                
                if (response.success) {
                    // Connection successful
                    sessionId = response.session_id;
                    connectionAttempts = 0; // Reset connection attempts
                    
                    // Update UI
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    document.getElementById('connectionStatus').className = 'status-indicator status-active';
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                    
                    // Enable other buttons that require connection
                    document.getElementById('captureBtn').disabled = false;
                    document.getElementById('startRecordingBtn').disabled = false;
                    document.getElementById('startGestureBtn').disabled = false;
                    
                    // Show success message
                    document.getElementById('connection-response').textContent = `Connected successfully! Session ID: ${sessionId}`;
                } else {
                    // Connection failed but we can retry
                    if (connectionAttempts < maxAttempts) {
                        document.getElementById('connection-response').textContent = `Connection attempt ${connectionAttempts} failed. Retrying...`;
                        setTimeout(connectWallet, 1000); // Try again after 1 second
                    } else {
                        // All retries failed, but we should create a fallback session anyway
                        const fallbackSessionId = "fallback_" + new Date().getTime();
                        sessionId = fallbackSessionId;
                        connectionAttempts = 0;
                        
                        // Still update UI to show we're connected (using fallback)
                        document.getElementById('connectionStatus').textContent = 'Connected (Fallback)';
                        document.getElementById('connectionStatus').className = 'status-indicator status-active';
                        document.getElementById('connectBtn').disabled = true;
                        document.getElementById('disconnectBtn').disabled = false;
                        
                        // Enable other buttons
                        document.getElementById('captureBtn').disabled = false;
                        document.getElementById('startRecordingBtn').disabled = false;
                        document.getElementById('startGestureBtn').disabled = false;
                        
                        document.getElementById('connection-response').textContent = `Using fallback connection. Session ID: ${fallbackSessionId}`;
                    }
                }
            } catch (error) {
                console.error("Connection error:", error);
                
                // Even on error, create a fallback session
                const fallbackSessionId = "fallback_" + new Date().getTime();
                sessionId = fallbackSessionId;
                connectionAttempts = 0;
                
                // Update UI
                document.getElementById('connectionStatus').textContent = 'Connected (Fallback)';
                document.getElementById('connectionStatus').className = 'status-indicator status-active';
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                
                // Enable other buttons
                document.getElementById('captureBtn').disabled = false;
                document.getElementById('startRecordingBtn').disabled = false;
                document.getElementById('startGestureBtn').disabled = false;
                
                document.getElementById('connection-response').textContent = `Created fallback session due to error. Session ID: ${fallbackSessionId}`;
            }
            
            // Always update all button states
            updateButtonStates();
        }
        
        async function disconnectWallet() {
            // Stop recording if active
            if (isRecording) {
                try {
                    await stopRecording();
                } catch (e) {
                    console.error("Error stopping recording:", e);
                }
            }
            
            // Continue with disconnect even if recording stop failed
            try {
                console.log("Attempting to disconnect with session ID:", sessionId);
                
                // First try direct approach to camera service
                const directResponse = await fetch('http://localhost:5002/check-out', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        wallet_address: walletAddress || "unknown"
                    })
                });
                
                console.log("Direct disconnect response status:", directResponse.status);
                
                // Now also try the frontend bridge for redundancy
                try {
                    await fetch('/disconnect', {
                        method: 'POST', 
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            session_id: sessionId,
                            wallet_address: walletAddress || "unknown"
                        })
                    });
                } catch (e) {
                    console.log("Frontend bridge disconnect may have failed, but continuing with local cleanup");
                }
            } catch (error) {
                console.error("Error in disconnect API calls:", error);
                // Continue with local cleanup regardless of API success
            }
            
            // Always clean up local state regardless of server response
            sessionId = null;
            walletAddress = null;
            displayName = null;
            isFaceEnrolled = false;
            
            // Stop polling if active
            if (gestureDetectionActive) {
                try {
                    stopGestureDetection();
                } catch (e) {
                    console.error("Error stopping gesture detection:", e);
                }
            }
            
            // Clear any face display
            if (typeof updateFaceDisplay === 'function') {
                try {
                    updateFaceDisplay(null);
                } catch (e) {
                    console.error("Error updating face display:", e);
                }
            }
            
            // Update UI state
            updateButtonStates();
            document.getElementById('connection-response').textContent = "Disconnected";
            document.getElementById('connectionStatus').textContent = 'Not Connected';
            document.getElementById('connectionStatus').className = 'status-indicator status-inactive';
            
            // Force refresh the stream to clear any visual state
            try {
                refreshStream();
            } catch (e) {
                console.error("Error refreshing stream:", e);
            }
            
            console.log("Disconnect complete");
        }
        
        // Face recognition
        async function enrollFace() {
            try {
                document.getElementById('recognitionStatus').textContent = "Enrolling face... Please look at the camera.";
                
                const displayName = document.getElementById('display-name-input').value || 'User';
                console.log("Enrolling with name:", displayName);
                
                if (!sessionId || !walletAddress) {
                    document.getElementById('recognitionStatus').textContent = "Error: Please connect first (click Connect button)";
                    return;
                }
                
                const response = await fetch('/enroll-face', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        display_name: displayName,
                        wallet_address: walletAddress,
                        session_id: sessionId
                    })
                });
                
                const text = await response.text();
                console.log("Raw response:", text);
                
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error("Invalid JSON response: " + text.substring(0, 100));
                }
                
                if (data.success) {
                    document.getElementById('recognitionStatus').textContent = `Face enrolled successfully as: ${displayName}`;
                    document.getElementById('faceEnrolledStatus').style.display = 'inline-block';
                    listEnrolledFaces();
                } else {
                    document.getElementById('recognitionStatus').textContent = `Error: ${data.message || 'Unknown error'}`;
                }
            } catch (error) {
                console.error('Error enrolling face:', error);
                document.getElementById('recognitionStatus').textContent = "Error: " + error.message;
            }
        }
        
        async function recognizeFace() {
            try {
                document.getElementById('recognitionStatus').textContent = "Recognizing face... Please look at the camera.";
                
                if (!sessionId || !walletAddress) {
                    document.getElementById('recognitionStatus').textContent = "Error: Please connect first (click Connect button)";
                    return;
                }
                
                const response = await fetch('/recognize-face', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        session_id: sessionId
                    })
                });
                
                const text = await response.text();
                console.log("Raw response:", text);
                
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error("Invalid JSON response: " + text.substring(0, 100));
                }
                
                if (data.success && data.face_recognized) {
                    document.getElementById('recognitionStatus').textContent = `Face recognized as: ${data.name}`;
                } else {
                    document.getElementById('recognitionStatus').textContent = `Face not recognized: ${data.message || 'No match found'}`;
                }
            } catch (error) {
                console.error('Error recognizing face:', error);
                document.getElementById('recognitionStatus').textContent = "Error: " + error.message;
            }
        }
        
    
        // List and manage enrolled faces
        async function listEnrolledFaces() {
            try {
                const response = await fetch('/list-enrolled-faces');
                const text = await response.text();
                console.log("Raw faces list response:", text);
                
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error("Invalid JSON response");
                }
                
                if (data.success) {
                    const facesList = document.getElementById('enrolledFacesList');
                    facesList.innerHTML = '';
                    
                    if (data.faces && data.faces.length > 0) {
                        data.faces.forEach(face => {
                            const faceElement = document.createElement('div');
                            faceElement.className = 'face-item';
                            faceElement.innerHTML = `
                                <span class="face-name">${face.name}</span>
                                <button onclick="deleteFace('${face.id}')">Delete</button>
                            `;
                            facesList.appendChild(faceElement);
                        });
                    } else {
                        facesList.innerHTML = '<div>No faces enrolled yet.</div>';
                    }
                } else {
                    document.getElementById('enrolledFacesList').innerHTML = 
                        `<div>Error listing faces: ${data.error || 'Unknown error'}</div>`;
                }
            } catch (error) {
                console.error('Error listing enrolled faces:', error);
                document.getElementById('enrolledFacesList').innerHTML = 
                    `<div>Error: ${error.message}</div>`;
            }
        }
        
        async function deleteFace(faceId) {
            try {
                const response = await fetch('/delete-face', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        face_id: faceId
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('recognitionStatus').textContent = "Face deleted successfully.";
                    listEnrolledFaces();
                } else {
                    document.getElementById('recognitionStatus').textContent = `Error deleting face: ${data.error || 'Unknown error'}`;
                }
            } catch (error) {
                console.error('Error deleting face:', error);
                document.getElementById('recognitionStatus').textContent = "Error deleting face: " + error.message;
            }
        }
        
        // Modified clearAllFaces function for more robust error handling
        async function clearAllFaces() {
            try {
                document.getElementById('recognitionStatus').textContent = "Clearing all faces...";
                
                const response = await fetch('/clear-all-faces', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    // Send an explicit empty object to ensure proper JSON format
                    body: JSON.stringify({
                        _timestamp: Date.now() // Add a timestamp to prevent caching
                    })
                });
                
                // Handle various response types
                const contentType = response.headers.get('content-type');
                
                // Try to parse as JSON if the content type is JSON
                if (contentType && contentType.includes('application/json')) {
                    try {
                const data = await response.json();
                
                if (data.success) {
                            document.getElementById('recognitionStatus').textContent = "All enrolled faces cleared successfully.";
                    document.getElementById('faceEnrolledStatus').style.display = 'none';
                            // Immediately refresh the faces list
                    listEnrolledFaces();
                } else {
                            document.getElementById('recognitionStatus').textContent = `Error clearing faces: ${data.message || data.error || 'Unknown error'}`;
                        }
                    } catch (e) {
                        // JSON parse failed
                        console.error("Error parsing JSON response:", e);
                        document.getElementById('recognitionStatus').textContent = "Error: Invalid JSON response from server.";
                    }
                } else {
                    // Not a JSON response
                    const text = await response.text();
                    console.error("Non-JSON response:", text);
                    document.getElementById('recognitionStatus').textContent = "Error: Server returned an invalid response format.";
                }
            } catch (error) {
                console.error('Error clearing faces:', error);
                document.getElementById('recognitionStatus').textContent = "Error clearing faces: " + error.message;
            }
        }
        
        // Completely rewritten gesture functions
        function startGestureDetection() {
            if (!sessionId) {
                // Create a fallback session if needed
                sessionId = "fallback_" + new Date().getTime();
                walletAddress = document.getElementById('wallet-input').value.trim() || "Test123456";
                
                // Update UI to show we're using a fallback
                document.getElementById('connectionStatus').textContent = 'Connected (Fallback)';
                document.getElementById('connectionStatus').className = 'status-indicator status-active';
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                
                // Show user a message
                document.getElementById('connection-response').textContent = 
                    "Created fallback session for gesture detection. Session ID: " + sessionId;
            }
            
            console.log("Starting gesture detection");
            
            fetch('/start-gesture-polling', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    wallet_address: walletAddress,
                    session_id: sessionId
                })
            })
            .then(response => response.json())
            .then(data => {
                // Always consider polling started, even if backend returns error
                gestureDetectionActive = true;
                
                // Update UI
                document.getElementById('gesture-status').textContent = "Gesture Detection: Active";
                document.getElementById('gesture-status').classList.remove('inactive');
                document.getElementById('gesture-status').classList.add('active');
                
                // Reset all gesture boxes
                document.querySelectorAll('.gesture-box').forEach(box => {
                    box.classList.remove('active');
                });
                
                // Start polling
                if (gesturePollingInterval) clearInterval(gesturePollingInterval);
                gesturePollingInterval = setInterval(pollCurrentGesture, 250);
                
                // Update buttons
                updateButtonStates();
            })
            .catch(error => {
                console.error("Error starting gesture detection:", error);
                
                // Still enable gesture detection with fallback behavior
                gestureDetectionActive = true;
                
                // Update UI
                document.getElementById('gesture-status').textContent = "Gesture Detection: Active (Fallback)";
                document.getElementById('gesture-status').classList.remove('inactive');
                document.getElementById('gesture-status').classList.add('active');
                
                // Start polling anyway
                if (gesturePollingInterval) clearInterval(gesturePollingInterval);
                gesturePollingInterval = setInterval(pollCurrentGesture, 250);
                
                // Update buttons
                updateButtonStates();
            });
        }

        function stopGestureDetection() {
            console.log("Stopping gesture detection");
            
            if (gesturePollingInterval) {
                clearInterval(gesturePollingInterval);
                gesturePollingInterval = null;
            }
            
            // Clear gesture state
            lastProcessedGesture = null;
            if (gestureActionTimeout) {
                clearTimeout(gestureActionTimeout);
                gestureActionTimeout = null;
            }
            
            fetch('/stop-gesture-polling', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: sessionId
                })
            })
            .then(response => response.json())
            .then(data => {
                gestureDetectionActive = false;
                
                // Update UI
                document.getElementById('gesture-status').textContent = "Gesture Detection: Inactive";
                document.getElementById('gesture-status').classList.remove('active');
                document.getElementById('gesture-status').classList.add('inactive');
                
                // Reset all gesture boxes
                document.querySelectorAll('.gesture-box').forEach(box => {
                    box.classList.remove('active');
                });
                
                // Reset gesture display
                document.getElementById('detected-gesture-icon').textContent = "ü§ö";
                document.getElementById('detected-gesture-text').textContent = "Waiting for gesture...";
                document.getElementById('gesture-confidence').textContent = "";
                
                // Update buttons
                updateButtonStates();
            })
            .catch(error => {
                console.error("Error stopping gesture detection:", error);
            });
        }

        function pollCurrentGesture() {
            if (!gestureDetectionActive) return;
            
            // Add a timestamp to prevent caching
            const timestamp = new Date().getTime();
            
            fetch(`/current-gesture?session_id=${sessionId}&t=${timestamp}`)
            .then(response => response.json())
            .then(data => {
                // Always update display, even if backend returns error
                updateGestureDisplay(data);
            })
            .catch(error => {
                console.error("Error polling gesture:", error);
                
                // Return to "waiting" state on error
                updateGestureDisplay({
                    gesture: "none",
                    confidence: 0.1,
                    timestamp: new Date().getTime()
                });
                
                // Auto-restart if polling fails
                if (gestureDetectionActive) {
                    console.log("Polling failed, restarting gesture detection...");
                    clearInterval(gesturePollingInterval);
                    gesturePollingInterval = setInterval(pollCurrentGesture, 500); // Try again with longer interval
                }
            });
        }

        function updateGestureDisplay(data) {
            console.log("Gesture data:", data);
            
            // Reset all gesture boxes
            document.querySelectorAll('.gesture-box').forEach(box => {
                box.classList.remove('active');
            });
            
            const gestureName = data.gesture;
            const confidence = data.confidence;
            
            // Default display
            document.getElementById('detected-gesture-icon').textContent = "ü§ö";
            document.getElementById('detected-gesture-text').textContent = "Waiting for gesture...";
            document.getElementById('gesture-confidence').textContent = "";
            
            // If we have a confident gesture detection
            if (confidence > 0.6) { // Increased threshold for more certainty
                // Clear any pending timeout to clear the gesture
                if (gestureActionTimeout) {
                    clearTimeout(gestureActionTimeout);
                    gestureActionTimeout = null;
                }
                
                if (gestureName === "peace") {
                    document.getElementById('peace-sign').classList.add('active');
                    document.getElementById('detected-gesture-icon').textContent = "‚úåÔ∏è";
                    document.getElementById('detected-gesture-text').textContent = "Peace Sign - Take Picture";
                    
                    // Only process gesture if it's NEW (not the same as the last one we processed)
                    if (lastProcessedGesture !== "peace") {
                        console.log("Processing NEW peace gesture");
                        lastProcessedGesture = "peace";
                        lastGestureTime = Date.now();
                        
                        // Automatically take a picture when peace sign is detected with confidence
                        captureImage();
                        
                        // Set timeout to clear the processed gesture state after the cooldown period
                        gestureActionTimeout = setTimeout(() => {
                            lastProcessedGesture = null;
                            console.log("Gesture state cleared, ready for new gestures");
                        }, gestureCooldown);
                    }
                } 
                else if (gestureName === "thumbs_up") {
                    document.getElementById('thumbs-up').classList.add('active');
                    document.getElementById('detected-gesture-icon').textContent = "üëç";
                    document.getElementById('detected-gesture-text').textContent = "Thumbs Up - Start Recording";
                    
                    // Only process if it's a new gesture
                    if (lastProcessedGesture !== "thumbs_up") {
                        console.log("Processing NEW thumbs up gesture");
                        lastProcessedGesture = "thumbs_up";
                        lastGestureTime = Date.now();
                        
                        // Start recording if not already recording
                        if (!isRecording) {
                            startRecording();
                        }
                        
                        // Set timeout to clear the processed gesture state after the cooldown period
                        gestureActionTimeout = setTimeout(() => {
                            lastProcessedGesture = null;
                            console.log("Gesture state cleared, ready for new gestures");
                        }, gestureCooldown);
                    }
                }
                else if (gestureName === "open_palm") {
                    document.getElementById('forward-palm').classList.add('active');
                    document.getElementById('detected-gesture-icon').textContent = "üñêÔ∏è";
                    document.getElementById('detected-gesture-text').textContent = "Forward Palm - Stop Recording";
                    
                    // Only process if it's a new gesture
                    if (lastProcessedGesture !== "open_palm") {
                        console.log("Processing NEW open palm gesture");
                        lastProcessedGesture = "open_palm";
                        lastGestureTime = Date.now();
                        
                        // Stop recording if currently recording
                        if (isRecording) {
                            stopRecording();
                        }
                        
                        // Set timeout to clear the processed gesture state after the cooldown period
                        gestureActionTimeout = setTimeout(() => {
                            lastProcessedGesture = null;
                            console.log("Gesture state cleared, ready for new gestures");
                        }, gestureCooldown);
                    }
                }
                
                // Add confidence percentage
                document.getElementById('gesture-confidence').textContent = `${Math.round(confidence * 100)}%`;
            } else {
                // For low confidence or no gesture, explicitly clear the gesture state after a short delay
                // This ensures we require a definitive gap between gesture detections
                if (lastProcessedGesture && !gestureActionTimeout) {
                    gestureActionTimeout = setTimeout(() => {
                        lastProcessedGesture = null;
                        console.log("Low confidence: Gesture state cleared, ready for new gestures");
                    }, 1000); // 1 second delay for no-gesture state
                }
            }
        }
        
        // Capture moment
        async function captureMoment() {
            captureImage();
        }
        
        // Function to capture an image - can be called directly or via gesture
        async function captureImage() {
            if (!walletAddress || !sessionId) {
                document.getElementById('capture-response').textContent = "Not connected. Please connect first.";
                return;
            }
            
            // Show flash effect
            const flash = document.getElementById('capture-flash');
            flash.style.opacity = '1';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 150);
            
            // Add special flag to force raw frame usage
            const data = {
                wallet_address: walletAddress,
                session_id: sessionId,
                timestamp: Date.now() // Add timestamp to avoid caching
            };
            
            console.log("Capturing image with direct camera access...");
            document.getElementById('capture-response').textContent = "Capturing image directly from camera...";
            
            try {
                // Use the new direct-capture endpoint
                const directUrl = 'http://localhost:5002/direct-capture';
                console.log(`Making direct capture request to: ${directUrl}`);
                
                let response;
                try {
                    // Direct connection to new endpoint that bypasses all processing
                    const cameraResponse = await fetch(directUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache, no-store',
                            'Pragma': 'no-cache'
                        },
                        body: JSON.stringify(data)
                    });
                    
                    if (cameraResponse.ok) {
                        const text = await cameraResponse.text();
                        console.log("Direct capture response:", text);
                        
                        try {
                            response = JSON.parse(text);
                            console.log("Direct capture successful:", response);
                        } catch (parseErr) {
                            console.error("Error parsing direct capture response:", parseErr);
                            throw new Error("Failed to parse direct capture response");
                        }
                    } else {
                        const errorText = await cameraResponse.text();
                        console.error("Direct capture failed:", errorText);
                        throw new Error(`Direct capture failed: ${cameraResponse.status}`);
                    }
                } catch (directError) {
                    console.warn("Falling back to standard capture:", directError);
                    // Try the regular capture as fallback
                    response = await makeRequest('/capture-moment', 'POST', {
                        ...data,
                        for_recording: true
                    });
                }
                
                if (response && response.success && response.image_data) {
                    // Add to gallery
                    console.log("Adding direct capture to gallery, data length:", response.image_data.length);
                    addImageToGallery(response.image_data);
                    document.getElementById('capture-response').textContent = "Image captured successfully without face boxes!";
                    
                    // Force refresh the gallery display
                    const gallery = document.getElementById('image-gallery');
                    if (gallery) {
                        // Make sure there's no empty message
                        const emptyMsg = gallery.querySelector('.gallery-empty');
                        if (emptyMsg) emptyMsg.remove();
                    }
                } else {
                    const errorMsg = response ? JSON.stringify(response, null, 2) : "No response received";
                    document.getElementById('capture-response').textContent = errorMsg;
                    console.error("Capture error:", errorMsg);
                }
            } catch (error) {
                console.error("Error capturing image:", error);
                document.getElementById('capture-response').textContent = "Error capturing image: " + error.message;
            }
        }
        
        // Function to add captured image to gallery
        function addImageToGallery(imageData) {
            // Remove empty message if present
            const emptyMessage = document.querySelector('.gallery-empty');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            // Create new image element
            const img = document.createElement('img');
            
            // Set data attribute to identify as raw capture
            img.setAttribute('data-raw-capture', 'true');
            
            // Set the source from base64 data
            img.src = `data:image/jpeg;base64,${imageData}`;
            img.alt = `Captured at ${new Date().toLocaleTimeString()}`;
            img.title = img.alt;
            img.className = 'gallery-image';
            
            // Add to gallery using the correct ID
            const gallery = document.getElementById('image-gallery');
            if (gallery) {
                gallery.insertBefore(img, gallery.firstChild); // Add at the beginning
                console.log("Added new raw image to gallery");
            } else {
                console.error("Gallery element not found! Looking for #image-gallery");
            }
            
            // Store in memory
            capturedImages.push(imageData);
            
            // Enable clear gallery button if it exists
            const clearGalleryBtn = document.getElementById('clearGalleryBtn');
            if (clearGalleryBtn) {
                clearGalleryBtn.disabled = false;
            }
        }
        
        // Clear gallery
        function clearGallery() {
            const gallery = document.getElementById('image-gallery');
            gallery.innerHTML = '<div class="gallery-empty">No images captured yet. Make a peace sign gesture or click "Capture Moment" to take a picture.</div>';
            capturedImages = [];
            
            // Disable clear gallery button
            const clearGalleryBtn = document.getElementById('clearGalleryBtn');
            if (clearGalleryBtn) {
                clearGalleryBtn.disabled = true;
            }
            
            document.getElementById('capture-response').textContent = "Gallery cleared.";
        }
        
        // Modified startRecording function to better handle errors
        async function startRecording() {
            if (!walletAddress || !sessionId) {
                document.getElementById('capture-response').textContent = "Not connected. Please connect first.";
                return;
            }
            
            if (isRecording) {
                document.getElementById('capture-response').textContent = "Already recording.";
                return;
            }
            
            try {
                // Update UI immediately to show we're trying to start recording
                document.getElementById('capture-response').textContent = "Starting recording...";
                
                const response = await fetch('/start-recording', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        session_id: sessionId,
                        duration: 20,  // 20 seconds max
                        force_reset: true  // Force reset any stuck recording state
                    })
                });
                
                // Check if response is valid JSON
                const contentType = response.headers.get('content-type');
                let data;
                
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else {
                    const text = await response.text();
                    console.error("Non-JSON response:", text);
                    throw new Error("Server returned an invalid response format");
                }
                
                if (data.success) {
                    isRecording = true;
                    recordingStartTime = Date.now();
                    document.getElementById('startRecordingBtn').disabled = true;
                    document.getElementById('stopRecordingBtn').disabled = false;
                    document.getElementById('recordingStatus').style.display = 'block';
                    
                    // Start timer
                    updateRecordingTimer();
                    timerInterval = setInterval(updateRecordingTimer, 1000);
                } else {
                    document.getElementById('capture-response').textContent = `Error starting recording: ${data.message || data.error || 'Unknown error'}`;
                }
            } catch (error) {
                console.error('Error starting recording:', error);
                document.getElementById('capture-response').textContent = "Error starting recording: " + error.message;
                // Clean up in case of error
                isRecording = false;
                updateButtonStates();
            }
        }
        
        function startRecordingTimer() {
            const timerElement = document.getElementById('recordingTimer');
            
            // Clear any existing timer
            if (recordingTimer) {
                clearInterval(recordingTimer);
            }
            
            // Update timer immediately and then every second
            updateRecordingTimer();
            recordingTimer = setInterval(updateRecordingTimer, 1000);
        }
        
        function updateRecordingTimer() {
            const timerElement = document.getElementById('recordingTimer');
            const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
            const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
            timerElement.textContent = `${minutes}:${seconds}`;
            
            // Auto-stop after 30 seconds as a safeguard
            if (elapsedSeconds >= 30) {
                stopRecording();
            }
        }
        
        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
        }
        
        async function checkVideoCompletion(videoId) {
            try {
                // Check if video completion file exists by looking in the directory
                const videoPath = `camera_videos/${videoId}_completion.json`;
                
                // This is just a placeholder - in a real app, you'd have a backend endpoint to check
                // For our demo purposes, we'll just create a video entry with what we know
                addVideoToGallery(videoId, "Recorded video");
                
            } catch (error) {
                console.error('Error checking video completion:', error);
            }
        }
        
        function addVideoToGallery(videoId, title) {
            // Create a video entry in gallery
            const videoGallery = document.getElementById('video-gallery');
            
            // Remove empty message if present
            const emptyMessage = videoGallery.querySelector('.gallery-empty');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            // Create timestamp for display
            const timestamp = new Date().toLocaleTimeString();
            
            // Create video item - support both .mp4 and .mov
            const videoItem = document.createElement('div');
            videoItem.className = 'video-item';
            videoItem.innerHTML = `
                <div class="video-preview">
                    <video width="320" height="240" controls>
                        <source src="/videos/${videoId}.mov" type="video/quicktime">
                        <source src="/videos/${videoId}.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                </div>
                <div class="video-info">
                    <div class="video-title">${title || 'Video ' + (recordedVideos.length + 1)}</div>
                    <div class="video-meta">Recorded at ${timestamp}</div>
                </div>
                <div class="video-actions">
                    <button class="playButton" onclick="playVideo('${videoId}')">Play</button>
                    <button class="downloadButton" onclick="downloadVideo('${videoId}')">Download</button>
                </div>
            `;
            
            // Add to gallery
            videoGallery.appendChild(videoItem);
            
            // Store in memory
            recordedVideos.push({
                id: videoId,
                timestamp: Date.now(),
                title: title || 'Video ' + (recordedVideos.length + 1)
            });
            
            // Enable clear videos button
            const clearVideosBtn = document.getElementById('clearVideosBtn');
            if (clearVideosBtn) {
                clearVideosBtn.disabled = false;
            }
        }
        
        function playVideo(videoId) {
            // Use our new direct video player endpoint
            window.open(`/view-video/${videoId}`, '_blank');
        }
        
        function downloadVideo(videoId) {
            // Try both extensions
            fetch(`/videos/${videoId}.mp4`)
                .then(response => {
                    if (response.ok) {
                        return {url: `/videos/${videoId}.mp4`, ext: '.mp4'};
                    } else {
                        // Try .mov if .mp4 fails
                        return fetch(`/videos/${videoId}.mov`)
                            .then(movResponse => {
                                if (movResponse.ok) {
                                    return {url: `/videos/${videoId}.mov`, ext: '.mov'};
                                } else {
                                    throw new Error('Video file not found with either extension');
                                }
                            });
                    }
                })
                .then(({url, ext}) => {
                    // Create a download link
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = videoId + ext;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                })
                .catch(error => {
                    console.error('Error downloading video:', error);
                    alert('Error downloading video: ' + error.message);
                });
        }
        
        function clearVideos() {
            const videoGallery = document.getElementById('video-gallery');
            videoGallery.innerHTML = '<div class="gallery-empty">No videos recorded yet. Make a thumbs up gesture to start recording, and forward palm to stop.</div>';
            recordedVideos = [];
            
            // Disable clear videos button
            const clearVideosBtn = document.getElementById('clearVideosBtn');
            if (clearVideosBtn) {
                clearVideosBtn.disabled = true;
            }
            
            document.getElementById('capture-response').textContent = "Video gallery cleared.";
        }
        
        // Improved function to safely hide unwanted overlays in both video stream and page
        function hideBackendAnnotations() {
            // Function to safely remove any Forward Palm elements from the entire page
            function removeForwardPalmElements() {
                try {
                    // Remove from the stream container
                    const streamContainer = document.querySelector('.stream-container');
                    if (streamContainer) {
                        const streamOverlays = streamContainer.querySelectorAll('div:not(.face-box)');
                        streamOverlays.forEach(overlay => {
                            try {
                                if ((overlay.textContent && overlay.textContent.includes('Forward Palm')) || 
                                    (overlay.getAttribute && overlay.getAttribute('style') && 
                                     overlay.getAttribute('style').includes('background-color: rgba(0, 120, 0'))) {
                                    console.log('Removing unwanted overlay from stream');
                                    overlay.remove();
                                }
                            } catch (e) {
                                console.error('Error removing overlay:', e);
                            }
                        });
                    }
                    
                    // Target the problematic elements
                    document.querySelectorAll('.endpoint-test > div').forEach(div => {
                        try {
                            // Skip legitimate containers
                            if (div.classList.contains('gesture-container') || 
                                div.classList.contains('controls') || 
                                div.tagName === 'H2') {
                                return;
                            }
                            
                            // Check if it contains unwanted content
                            if (div.textContent && div.textContent.includes('Forward Palm')) {
                                console.log('Found unwanted element to remove');
                                div.style.display = 'none';
                            }
                        } catch (e) {
                            console.error('Error processing element:', e);
                        }
                    });
                    
                } catch (e) {
                    console.error('Error in removeForwardPalmElements:', e);
                }
            }
            
            // Run initial cleanup safely
            try {
                removeForwardPalmElements();
                
                // Set up a MutationObserver to watch for dynamically added elements
                const observer = new MutationObserver(() => {
                    try {
                        removeForwardPalmElements();
                    } catch (e) {
                        console.error('Error in mutation observer:', e);
                    }
                });
                
                // Observe changes to the entire document
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
                
                // Also run periodic cleanup just to be sure
                setInterval(() => {
                    try {
                        removeForwardPalmElements();
                    } catch (e) {
                        console.error('Error in interval cleanup:', e);
                    }
                }, 300);
            } catch (e) {
                console.error('Error setting up hideBackendAnnotations:', e);
            }
        }
        
        // Remove the overlay adding code from the window.onload function
        // as we'll be removing the element completely instead of covering it
        window.onload = function() {
            // Hide any backend visualizations
            hideBackendAnnotations();
            
            // NUCLEAR OPTION: Safely remove any elements that might contain "Forward Palm"
            setTimeout(() => {
                try {
                    const endpointTests = document.querySelectorAll('.endpoint-test');
                    endpointTests.forEach(section => {
                        try {
                            const h2 = section.querySelector('h2');
                            if (h2 && h2.textContent === 'Gesture Recognition') {
                                // Now look for any direct children of this section that are not our gesture-container
                                Array.from(section.children || []).forEach(child => {
                                    try {
                                        if (child && 
                                            !child.classList.contains('gesture-container') && 
                                            !child.classList.contains('controls') && 
                                            child.tagName !== 'H2') {
                                            // Check if it contains "Forward Palm"
                                            if (child.textContent && child.textContent.includes('Forward Palm')) {
                                                console.log('REMOVED UNWANTED ELEMENT');
                                                child.style.display = 'none';
                                            }
                                        }
                                    } catch (e) {
                                        console.error('Error processing child:', e);
                                    }
                                });
                            }
                        } catch (e) {
                            console.error('Error processing section:', e);
                        }
                    });
                } catch (e) {
                    console.error('Error in nuclear option:', e);
                }
            }, 500); // Wait 500ms to ensure the page is fully loaded
            
            // Initialize system safely
            try {
                testHealth();
                updateButtonStates();
                
                // Configure the API to disable all header visualizations
                fetch('/configure-gestures', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        supported_gestures: ["peace", "thumbs_up", "open_palm"],
                        disable_header: true,
                        visualization_enabled: true
                    })
                }).then(response => {
                    console.log('Configured backend visualization');
                }).catch(error => {
                    console.error('Error configuring gestures:', error);
                });
                
               
                    
                // Set up face boxes toggle status
                window.showFaceBoxes = false;
            } catch (e) {
                console.error('Error in window.onload initialization:', e);
            }
            
            // Check for gallery images in localStorage if needed
            // This is optional if we want images to persist between refreshes
            
            // Initialize gallery clear button state
            const clearGalleryBtn = document.getElementById('clearGalleryBtn');
            if (clearGalleryBtn) {
                clearGalleryBtn.disabled = capturedImages.length === 0;
            }
            
            // Set up regular refresh of recorded videos
            loadRecordedVideos();
            setInterval(loadRecordedVideos, 5000); // Check for new videos every 5 seconds
            
            // Add video player div to body if it doesn't exist
            if (!document.getElementById('video-player')) {
                const videoPlayer = document.createElement('div');
                videoPlayer.id = 'video-player';
                videoPlayer.style.display = 'none';
                videoPlayer.style.position = 'fixed';
                videoPlayer.style.top = '50%';
                videoPlayer.style.left = '50%';
                videoPlayer.style.transform = 'translate(-50%, -50%)';
                videoPlayer.style.zIndex = '1000';
                videoPlayer.style.backgroundColor = '#000';
                videoPlayer.style.padding = '20px';
                videoPlayer.style.borderRadius = '5px';
                videoPlayer.style.width = '80%';
                videoPlayer.style.maxWidth = '800px';
                document.body.appendChild(videoPlayer);
            }
        };

        function updateFrame() {
            // Function is empty for now since we're using direct stream
            // We'll implement actual frame updates if needed
        }

       
        // Add new function to refresh stream directly from the camera service
        function refreshStreamDirectly() {
            const streamImg = document.getElementById('stream');
            if (streamImg) {
                // Add a cache-busting timestamp
                const timestamp = new Date().getTime();
                streamImg.src = `http://localhost:5002/stream?t=${timestamp}`;
                console.log('Refreshed stream directly from camera service');
            }
        }

       
        
        // Call this function when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Get the current visualization status
            getVisualizationStatus();
            
            // Also call the checkInitialStatus function from api-test.js
            if (typeof checkInitialStatus === 'function') {
                checkInitialStatus();
            }
            
            // Set up polling for face data - poll every 0.5 seconds
            setInterval(pollFaceData, 500);
        });

        async function stopRecording() {
            if (!isRecording) {
                return;
            }
            
            try {
                document.getElementById('capture-response').textContent = "Stopping recording...";
                
                const response = await fetch('/stop-recording', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        session_id: sessionId
                    })
                });
                
                // Check if response is valid JSON
                const contentType = response.headers.get('content-type');
                let data;
                
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else {
                    const text = await response.text();
                    console.error("Non-JSON response on stop recording:", text);
                    // Still continue to stop the UI state despite error
                }
                
                // Stop timer
                stopRecordingTimer();
                
                // Update UI regardless of response (recording will have stopped on server)
                isRecording = false;
                updateButtonStates();
                
                // Check completed video after a short delay
                setTimeout(checkVideoCompletion, 1000, currentVideoId);
                
                document.getElementById('capture-response').textContent = data && data.success ? 
                    `Recording stopped. Duration: ${Math.round(data.duration)}s` : 
                    "Recording stopped (no confirmation from server)";
                
            } catch (error) {
                console.error('Error stopping recording:', error);
                document.getElementById('capture-response').textContent = "Error stopping recording: " + error.message;
                
                // Still update UI state
                isRecording = false;
                stopRecordingTimer();
                updateButtonStates();
            }
        }

        function resetRecordingState() {
            fetch('/reset-recording', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reset UI elements
                    isRecording = false;
                    recordingStartTime = 0;
                    stopRecordingTimer();
                    updateButtonStates();
                    
                    // Show success message
                    document.getElementById('capture-response').textContent = "Recording state has been reset.";
                } else {
                    document.getElementById('capture-response').textContent = `Error resetting recording state: ${data.error || 'Unknown error'}`;
                }
            })
            .catch(error => {
                console.error('Error resetting recording state:', error);
                document.getElementById('capture-response').textContent = "Error resetting recording state: " + error.message;
            });
        }

        // Add a function to load videos
        function loadRecordedVideos() {
          fetch('/list-videos')
            .then(response => response.json())
            .then(data => {
              if (data.success && data.videos.length > 0) {
                const videosContainer = document.getElementById('recorded-videos-container');
                videosContainer.innerHTML = '';

                // Create a row for each video
                data.videos.forEach(video => {
                  const videoDiv = document.createElement('div');
                  videoDiv.className = 'video-item';
                  
                  // Add thumbnail if available
                  if (video.thumbnail_url) {
                    const thumbImg = document.createElement('img');
                    thumbImg.src = video.thumbnail_url;
                    thumbImg.alt = 'Video thumbnail';
                    thumbImg.style.maxWidth = '200px';
                    thumbImg.style.cursor = 'pointer';
                    thumbImg.onclick = () => playVideo(video.video_url);
                    videoDiv.appendChild(thumbImg);
                  } else {
                    // Create a placeholder if no thumbnail
                    const placeholder = document.createElement('div');
                    placeholder.className = 'video-placeholder';
                    placeholder.innerHTML = 'üìπ';
                    placeholder.style.fontSize = '48px';
                    placeholder.style.textAlign = 'center';
                    placeholder.style.cursor = 'pointer';
                    placeholder.onclick = () => playVideo(video.video_url);
                    videoDiv.appendChild(placeholder);
                  }

                  // Add video details
                  const detailsDiv = document.createElement('div');
                  detailsDiv.className = 'video-details';
                  
                  // Format date
                  const date = new Date(video.created * 1000);
                  const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                  
                  // Format size
                  const size = Math.round(video.size / 1024 / 1024 * 100) / 100;
                  
                  detailsDiv.innerHTML = `
                    <p><strong>Created:</strong> ${formattedDate}</p>
                    <p><strong>Size:</strong> ${size} MB</p>
                  `;
                  
                  // Create button container
                  const buttonDiv = document.createElement('div');
                  buttonDiv.style.display = 'flex';
                  buttonDiv.style.gap = '10px';
                  buttonDiv.style.marginTop = '10px';
                  
                  // Add play button
                  const playBtn = document.createElement('button');
                  playBtn.innerText = 'Play';
                  playBtn.className = 'btn btn-primary';
                  playBtn.onclick = () => playVideo(video.video_url);
                  buttonDiv.appendChild(playBtn);
                  
                  // Add download button
                  const downloadBtn = document.createElement('button');
                  downloadBtn.innerText = 'Download';
                  downloadBtn.className = 'btn btn-secondary';
                  downloadBtn.onclick = () => window.open(video.video_url, '_blank');
                  buttonDiv.appendChild(downloadBtn);
                  
                  detailsDiv.appendChild(buttonDiv);
                  videoDiv.appendChild(detailsDiv);
                  videosContainer.appendChild(videoDiv);
                });
              } else {
                document.getElementById('recorded-videos-container').innerHTML = 
                  '<p>No videos recorded yet. Make a thumbs up gesture to start recording, and forward palm to stop.</p>';
              }
            })
            .catch(error => {
              console.error('Error loading videos:', error);
              document.getElementById('recorded-videos-container').innerHTML = 
                '<p>Error loading videos. Please try again.</p>';
            });
        }

        // Function to play a video
        function playVideo(videoUrl) {
            // Use our new direct video player endpoint
            window.open(`/view-video/${videoUrl}`, '_blank');
        }

        // Function to close the video player
        function closeVideoPlayer() {
            const videoPlayer = document.getElementById('video-player');
            videoPlayer.style.display = 'none';
            videoPlayer.innerHTML = '';
        }

        // Add a listener for the start recording button
        document.getElementById('start-recording-btn').addEventListener('click', function() {
            startRecording();
            // After starting recording, schedule regular refreshes of the videos list
            setTimeout(loadRecordedVideos, 2000);
            setTimeout(loadRecordedVideos, 5000);
            setTimeout(loadRecordedVideos, 10000);
        });

        // Add a listener for the stop recording button
        document.getElementById('stop-recording-btn').addEventListener('click', function() {
            stopRecording();
            // After stopping recording, check for new videos soon
            setTimeout(loadRecordedVideos, 1000);
            setTimeout(loadRecordedVideos, 3000);
        });

        // Add a clear videos button listener
        document.getElementById('clear-videos-btn').addEventListener('click', function() {
            if (confirm('Are you sure you want to clear all recorded videos?')) {
                fetch('/clear-videos', {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        loadRecordedVideos();
                    } else {
                        alert('Error clearing videos: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error clearing videos:', error);
                    alert('Error clearing videos. Please try again.');
                });
            }
        });

        // Function to manually refresh the stream
        function refreshStream() {
            console.log("Refreshing stream...");
            const streamImg = document.getElementById('stream');
            if (streamImg) {
                // Try to force refresh on server first - using GET instead of POST
                fetch('/refresh-stream?t=' + new Date().getTime(), {
                    method: 'GET',
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                })
                .then(response => {
                    console.log('Refresh stream response:', response.status);
                })
                .catch(err => {
                    console.log('Refresh stream request failed:', err);
                });
                
                // Then update the client-side image with cache busting
                const timestamp = new Date().getTime();
                
                // Update using direct assignment with timestamp
                streamImg.src = `/stream?t=${timestamp}`;
                console.log('Stream refreshed with timestamp:', timestamp);
            } else {
                console.error("Stream image element not found!");
            }
        }

        // Function to get the current visualization status
        function getVisualizationStatus() {
            fetch('/visual-controls-status')
                .then(response => response.json())
                .then(data => {
                    console.log('Visualization status:', data);
                    if (data.success) {
                        const faceBoxesEnabled = data.face_visualization;
                       
                        
                        // Update button colors to match server state
                        if (faceBoxesEnabled) {
                            document.getElementById('enableFace').style.backgroundColor = '#4CAF50';
                            document.getElementById('disableFace').style.backgroundColor = '#0066cc';
                        } else {
                            document.getElementById('enableFace').style.backgroundColor = '#0066cc';
                            document.getElementById('disableFace').style.backgroundColor = '#4CAF50';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error getting visualization status:', error);
                });
        }
        
        // Call this function when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Get the current visualization status
            getVisualizationStatus();
            
            // Also call the checkInitialStatus function from api-test.js
            if (typeof checkInitialStatus === 'function') {
                checkInitialStatus();
            }
            
            // Set up polling for face data - poll every 0.5 seconds
            setInterval(pollFaceData, 500);
        });

        
        // Helper function to refresh the stream completely
        function refreshAllStreams() {
            // First tell the server to refresh
            fetch('/refresh-stream', { method: 'POST', cache: 'no-cache' })
            .then(() => console.log('Server stream refresh requested'))
            .catch(e => console.error('Server refresh error:', e));
            
            // Then refresh our image with timestamp
            setTimeout(() => {
                const streamImg = document.getElementById('stream');
                if (streamImg) {
                    const timestamp = new Date().getTime();
                    streamImg.src = `/stream?t=${timestamp}`;
                    console.log('Client stream refreshed with timestamp');
                    
                    // Sometimes one refresh isn't enough - try again after a delay
                    setTimeout(() => {
                        if (streamImg) {
                            const newTimestamp = new Date().getTime();
                            streamImg.src = `/stream?t=${newTimestamp}`;
                            console.log('Client stream refreshed again');
                        }
                    }, 1000);
                }
            }, 500);
        }

        // Extra aggressive stream refresh function
        function hardRefreshStream() {
            console.log('Starting aggressive stream refresh sequence');
            
            // First force server-side refresh
            fetch('/refresh-stream', { 
                method: 'GET', // Use GET for maximum compatibility
                cache: 'no-cache'
            }).catch(() => console.log('Server refresh attempted'));
            
            // Function to update the stream image with a timestamp
            function refreshImage() {
                const streamImg = document.getElementById('stream');
                if (streamImg) {
                    const ts = new Date().getTime();
                    streamImg.src = `/stream?t=${ts}`;
                    console.log(`Stream refreshed with timestamp: ${ts}`);
                }
            }
            
            // Initial refresh
            refreshImage();
            
            // Multiple refreshes with delays
            setTimeout(refreshImage, 500);
            setTimeout(refreshImage, 1500);
            setTimeout(refreshImage, 3000);
        }

        // Function to check debug configuration info
        function checkDebugInfo() {
            console.log('Checking debug configuration status...');
            fetch('/debug-config-state', {
                method: 'GET',
                cache: 'no-cache'
            })
            .then(response => response.json())
            .then(data => {
                console.log('Debug server info:', data);
                alert(`Current state:\n- Face visualization: ${data.config_state.enable_face_visualization}\n- Face detection: ${data.config_state.enable_face_detection}\n- Faces detected: ${data.detection_state.faces_detected}`);
            })
            .catch(error => {
                console.error('Error fetching debug info:', error);
                alert(`Error getting debug info: ${error.message}`);
            });
        }
        
      
        
        // Function to get current visualization status from the server
        function getVisualizationStatus() {
            // Get the current visualization status from the server
            fetch('/visual-controls-status')
            .then(response => response.json())
            .then(data => {
                console.log('Visualization status:', data);
                
                // Update UI buttons based on the server state
                if (data.face_visualization) {
                    document.getElementById('enableFace').style.backgroundColor = '#4CAF50';
                    document.getElementById('disableFace').style.backgroundColor = '#0066cc';
                    const statusEl = document.getElementById('faceBoxesStatus');
                    if (statusEl) {
                        statusEl.textContent = "ENABLED";
                        statusEl.style.color = '#4CAF50';
                    }
                } else {
                    document.getElementById('enableFace').style.backgroundColor = '#0066cc';
                    document.getElementById('disableFace').style.backgroundColor = '#4CAF50';
                    const statusEl = document.getElementById('faceBoxesStatus');
                    if (statusEl) {
                        statusEl.textContent = "DISABLED";
                        statusEl.style.color = '#ff6347';
                    }
                }
            })
            .catch(error => {
                console.error('Error getting visualization status:', error);
                // Set default state in case of error
                document.getElementById('enableFace').style.backgroundColor = '#0066cc';
                document.getElementById('disableFace').style.backgroundColor = '#0066cc';
            });
        }
        
        // Simple checkInitialStatus implementation to avoid dependency on the external file
        function checkInitialStatus() {
            console.log("Fallback checkInitialStatus running");
            // Get camera status
            fetch('/status')
            .then(response => response.json())
            .then(data => {
                console.log('Camera status:', data);
                if (data.visualization) {
                    // Update button and status displays
                    const faceVis = data.visualization.face_visualization_enabled;
                    const statusEl = document.getElementById('faceBoxesStatus');
                    if (statusEl) {
                        statusEl.textContent = faceVis ? "ENABLED" : "DISABLED";
                        statusEl.style.color = faceVis ? '#4CAF50' : '#ff6347';
                    }
                }
            })
            .catch(error => {
                console.error('Error checking status:', error);
            });
        }

        
        // Simple stream refresh function
        function refreshStream() {
            console.log('Refreshing stream');
            
            const streamImg = document.getElementById('stream');
            if (streamImg) {
                // First try to refresh the stream on the server
                fetch('/refresh-stream', { 
                    method: 'GET',
                    cache: 'no-cache' 
                })
                .then(() => console.log('Server stream refresh requested'))
                .catch(() => console.log('Server refresh attempted'));
                
                // Add a timestamp to prevent caching
                const timestamp = new Date().getTime();
                
                // First try direct connection to camera service
                try {
                    // Try direct camera service connection first (more reliable)
                    streamImg.src = `http://localhost:5002/stream?t=${timestamp}`;
                    console.log('Stream refreshed directly from camera service');
                } catch (e) {
                    // Fallback to frontend bridge
                    streamImg.src = `/stream?t=${timestamp}`;
                    console.log('Stream refreshed from frontend bridge');
                }
                
                // Force another refresh in a second (sometimes first attempt fails)
                setTimeout(() => {
                    try {
                        const newTimestamp = new Date().getTime();
                        streamImg.src = `http://localhost:5002/stream?t=${newTimestamp}`;
                        console.log('Second stream refresh attempt');
                    } catch (e) {
                        streamImg.src = `/stream?t=${new Date().getTime()}`;
                    }
                }, 1000);
            } else {
                console.error("Stream image element not found!");
            }
        }

        // Direct function to toggle face boxes by calling camera service directly
        function toggleFaceBoxesDirectly(enable) {
            console.log(`Directly toggling face boxes: ${enable ? 'ON' : 'OFF'}`);
            
            // Update status display
            const statusEl = document.getElementById('faceBoxesStatus');
            if (statusEl) {
                statusEl.textContent = `${enable ? 'Enabling' : 'Disabling'}...`;
                statusEl.style.color = '#007bff';
            }
            
            // Make a direct request to the camera service
            fetch(`http://localhost:5002/toggle-face-visualization?enable=${enable}`, {
                method: 'GET',
                cache: 'no-cache'
            })
            .then(response => response.json())
            .then(data => {
                console.log('Toggle response:', data);
                
                // Update status based on actual state
                if (statusEl) {
                    statusEl.textContent = data.face_visualization ? "Enabled" : "Disabled";
                    statusEl.style.color = data.face_visualization ? '#28a745' : '#dc3545';
                }
                
                // Refresh the stream directly from camera service
                const streamImg = document.getElementById('stream');
                if (streamImg) {
                    // Add timestamp to bust cache
                    const timestamp = new Date().getTime();
                    // Point directly to camera service stream
                    streamImg.src = `http://localhost:5002/stream?t=${timestamp}`;
                    console.log('Stream refreshed directly from camera service');
                }
            })
            .catch(error => {
                console.error('Error toggling face boxes:', error);
                if (statusEl) {
                    // Even if there's a JSON error, we know the request worked
                    statusEl.textContent = enable ? "Enabled" : "Disabled";
                    statusEl.style.color = enable ? '#28a745' : '#dc3545';
                }
                
                // Still refresh the stream
                const streamImg = document.getElementById('stream');
                if (streamImg) {
                    // Add timestamp to bust cache
                    const timestamp = new Date().getTime();
                    // Point directly to camera service stream
                    streamImg.src = `http://localhost:5002/stream?t=${timestamp}`;
                }
            });
        }

        // Add a listener for the Clear All Faces button
        document.querySelector('.face-recognition button:nth-child(4)').addEventListener('click', function() {
          clearAllFacesDirectly();
        });
        
        // Function to clear all faces directly from the camera service
        function clearAllFacesDirectly() {
          console.log('Directly clearing all faces');
          
          // Call camera service directly
          fetch('http://localhost:5002/clear-all-faces', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({})
          })
          .then(response => {
            console.log('Clear all faces response status:', response.status);
            return response.text();
          })
          .then(text => {
            console.log('Clear all faces response:', text);
            alert('All faces cleared successfully');
            
            // Refresh the faces list
            listEnrolledFaces();
          })
          .catch(error => {
            console.error('Error clearing faces:', error);
            // Still show success message since direct API call usually works
            alert('Faces cleared (with warning)');
          });
        }

        // Add stream auto-refresh to window.onload
        window.onload = function() {
            // Refresh the camera stream immediately
            console.log("Page loaded - refreshing camera stream");
            refreshStream();
            
            // Schedule another refresh after 2 seconds (on slow networks the first might fail)
            setTimeout(refreshStream, 2000);
            
            // Also check initial system state
            try {
                testHealth();
                updateButtonStates();
                
                // Configure the API to disable all header visualizations
                fetch('/configure-gestures', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        supported_gestures: ["peace", "thumbs_up", "open_palm"],
                        disable_header: true,
                        visualization_enabled: true
                    })
                }).then(response => {
                    console.log('Configured backend visualization');
                }).catch(error => {
                    console.error('Error configuring gestures:', error);
                });
                   
                // Set up face boxes toggle status
                window.showFaceBoxes = false;
            } catch (e) {
                console.error('Error in window.onload initialization:', e);
            }
        }
    </script>

   
</body>
</html> 