# Privacy-Preserving Timeline Architecture

**Status:** Planning / Ready for Implementation
**Last Updated:** November 24, 2024
**Goal:** Eliminate surveillance-friendly onchain data while maintaining decentralized proof-of-presence

---

## The Core Concept: "Boxes with Memory"

Think of each camera as a **vending machine on the internet for capturing IRL moments**. Each camera is a "box" that:

- Starts in dormant mode (memory off)
- Activates when first user checks in (memory on)
- Records everything that happens with perfect quality
- Users don't "own" the activities - they receive **view access** to the box's memory
- Your visibility is 100% dependent on when you were physically present in the box
- Goes dormant when last person leaves

**Users aren't keeping memories for themselves - they're receiving time-windowed view access to the venue's photographic memory.**

---

## The Problem We're Solving

### Current Architecture Issues

**1. Block Explorer Surveillance**
- Every user action creates an onchain transaction
- Public explorers can map: `User X → Camera Y → Timestamp Z`
- Creates surveillance-friendly permanent record of movement patterns
- Example: "Alice visited Boulder Gym every Tuesday at 6pm for 6 months"

**2. Per-Action Transaction Costs**
- Check-in: 1 tx, Each photo: 1 tx, Check-out: 1 tx
- 30-minute session with 10 photos = 12 transactions
- Microfees create UX friction

**3. Overly Permissive Timeline Visibility**
- Current: Anyone checked in sees ALL historical activity
- No privacy boundaries based on temporal overlap

### Why This Matters

We're building a **lived social graph generated by IRL presence**. If backend dies, users should still:
1. Prove they were at a location at a specific time
2. Decrypt their own historical activities
3. See activities from people present during their sessions

**This requires true decentralization.**

---

## The Three-Layer Architecture

### Layer 1: Onchain Timeline (Solana - Source of Truth)

**Camera Account with Encrypted Timeline:**
```rust
CameraAccount {
    camera_id: Pubkey,
    owner: Pubkey,
    encrypted_timeline: Vec<EncryptedActivity>,  // Grows forever
    active_session_count: u8,
}

EncryptedActivity {
    timestamp: i64,              // Public (needed for overlap queries)
    activity_type: u8,           // Public (photo, video, etc.)
    encrypted_content: Vec<u8>,  // AES encrypted activity data
    access_grants: Vec<Vec<u8>>, // Each user's encrypted key
}
```

**This timeline is the canonical memory of the box. Lives on Solana permanently.**

**Storage:** Use Light Protocol's ZK Compression (5000x cheaper) to handle large timelines efficiently.

---

### Layer 2: Jetson (Bundling & Efficiency)

**Jetson's Role:**
- Captures activities in real-time (photos via Pipe Network, not IPFS)
- Buffers activities locally during active session
- On user checkout: encrypts and bundles all activities
- Submits ONE transaction to append bundle to camera's timeline
- Tracks who's currently checked in (for access grants)

**Reduces transactions from N activities → 1 bundle per checkout**

**Redundancy:** Backend also maintains copy of buffered activities in case Jetson crashes.

---

### Layer 3: Privacy Layer (Obfuscation)

Two things need privacy:

**A) User-Camera Association (Shielded Sessions)**

Instead of storing user's wallet address directly:
```rust
// OLD (surveillance-friendly):
UserSession { user: Alice_Pubkey, camera: Gym, time: 10:00 }

// NEW (pseudonymous):
ShieldedSession {
    session_id: hash(user + camera + time),  // Pseudonymous ID
    camera: Gym,                              // Public (needed for queries)
    check_in_time: 10:00,                    // Public (needed for overlap)
    check_out_time: 11:00,                   // Public (needed for overlap)
    encrypted_user: encrypt(Alice, camera_key) // Hidden from explorers
}
```

Block explorers see: "Some session at Gym 10:00-11:00" but NOT "Alice was there"

**B) Activity Content (Wallet-Based Encryption)**

Each activity uses standard asymmetric encryption:
```
1. Generate random key: K_activity
2. Encrypt activity data with K_activity:
   encrypted_content = AES_encrypt({
       type: "photo",
       pipe_url: "pipe://...",
       users_present: ["Alice", "Bob"]
   }, K_activity)

3. For each user present, encrypt K_activity to their wallet pubkey:
   access_grants = [
       encrypt_to_pubkey(K_activity, Alice_wallet),
       encrypt_to_pubkey(K_activity, Bob_wallet)
   ]

4. Store onchain in camera's timeline
```

**Users decrypt with their WALLET PRIVATE KEY - no backend needed.**

---

## Complete Data Flow

### 1. First User Arrives

```
Alice checks in to Boulder Gym at 10:00:

Frontend → Solana:
  - create_shielded_session(camera_id, user_pubkey, timestamp)
  - Stores: { session_id: hash(...), camera, time: 10:00, encrypted_user }
  - Camera.active_session_count = 1

Backend tells Jetson:
  - "Session started, user pubkey = Alice_Pubkey"
  - Jetson starts buffering activities
```

### 2. Activities Happen

```
10:15 - Alice takes photo:
  - Jetson captures, uploads to Pipe Network
  - Jetson buffers locally: {
      type: "photo",
      timestamp: 10:15,
      pipe_url: "pipe://QmXYZ",
      users_present: [Alice_Pubkey]
    }

10:30 - Bob checks in:
  - New shielded session created
  - Camera.active_session_count = 2
  - Jetson now tracking: [Alice, Bob]

10:45 - Video recorded:
  - Jetson buffers: {
      type: "video",
      timestamp: 10:45,
      pipe_url: "pipe://QmABC",
      users_present: [Alice_Pubkey, Bob_Pubkey]  // Both present
    }
```

### 3. User Checks Out (The Key Transaction)

```
11:00 - Alice checks out:

Checkout transaction does THREE things atomically:
  1. Closes UserSession account
  2. Encrypts buffered activities (10:00-11:00)
  3. Appends to camera's onchain timeline

Encryption process:
  For photo@10:15:
    K1 = random_key()
    encrypted_content = AES_encrypt(photo_data, K1)
    access_grants = [encrypt(K1, Alice_wallet)]  // Only Alice present

  For video@10:45:
    K2 = random_key()
    encrypted_content = AES_encrypt(video_data, K2)
    access_grants = [
        encrypt(K2, Alice_wallet),  // Both get access
        encrypt(K2, Bob_wallet)
    ]

Camera.timeline.push(encrypted_activities)
Camera.active_session_count = 1  // Bob still there
```

**User pays fees for checkout. Jetson provides activity bundle to transaction.**

### 4. Auto-Checkout (Mandatory Bot)

**Extending existing auto-checkout mechanism:**

```rust
// Current implementation (check_out.rs lines 48-56)
let is_expired = now > session.auto_checkout_at;  // 2 hour timeout

// Allow checkout if user OR if expired (anyone can cleanup for rent)
if is_expired {
    // Bot calls checkout with buffered activities
    // Bot pays fees, gets rent reward as incentive
}
```

**Bot needs to:**
1. Monitor for expired sessions (existing)
2. Fetch buffered activities from Backend API
3. Call `check_out_with_activities(session, activities)`
4. Collect rent reward (existing incentive)

**Failure scenarios:**
- Jetson crashes: Backend has redundant activity copy
- Backend crashes: Jetson has local copy
- Both crash: Activities lost (rare, acceptable risk)

---

## Querying Timeline (User POV)

### Alice Views Timeline (6 Months Later)

```
1. Alice: "Show me Boulder Gym timeline"

2. Frontend fetches Alice's sessions:
   - Queries Solana for shielded sessions
   - Decrypts encrypted_user field with camera key (stored in backend)
   - Finds: { camera: Gym, start: 10:00, end: 11:00 }

3. Frontend fetches camera's timeline:
   - Queries Solana: camera.encrypted_timeline
   - Gets ALL EncryptedActivity entries (public data)

4. Frontend filters by Alice's timeframe:
   - Only processes activities with timestamp 10:00-11:00

5. Frontend decrypts with Alice's wallet:
   For each activity:
     - Try to decrypt access_grants with Alice's private key
     - If successful, get K_activity
     - Use K_activity to decrypt encrypted_content
     - Display photo/video

6. Alice sees:
   - Photo@10:15 (she was there)
   - Video@10:45 (she and Bob both there)
   - Does NOT see photo@11:30 (she left at 11:00)
```

### Carol (Never There) Tries to View

```
1. Carol queries camera timeline
2. Fetches encrypted activities
3. Tries to decrypt access_grants with her wallet key
4. ALL decryption attempts fail (no grants encrypted to her)
5. Result: Carol sees nothing
```

**Privacy enforced cryptographically, not by backend permissions.**

---

## Privacy Guarantees

### What Block Explorers See:
- Camera account with growing encrypted timeline
- Pseudonymous session IDs (hashes, not wallet addresses)
- Timestamps (needed for overlap logic)
- Encrypted blobs they can't read

### What They DON'T See:
- "Alice visited Boulder Gym"
- What activities happened
- Who was present during activities

### What Users Can Do:
- Decrypt only their time windows
- Prove they were present (show decrypted activities)
- Keep access even if mmoment dies (wallet keys are theirs)

### Backend's Role:
- Temporary buffer for efficiency (NOT decryption key holder)
- Can disappear after checkout - all data onchain
- Maps session_id → user (can be encrypted/forgotten)

---

## Technical Details

### Encryption Specifics

**Activity Encryption (AES-256-GCM):**
```rust
// Random key per activity
let K_activity = generate_random_bytes(32);

// Encrypt activity data
let nonce = generate_nonce();
let encrypted_content = aes_256_gcm_encrypt(
    activity_data,
    K_activity,
    nonce
);
```

**Access Grants (RSA/Ed25519 Encryption):**
```rust
// For each user present, encrypt activity key to their wallet pubkey
for user_pubkey in users_present {
    let encrypted_key = encrypt_to_ed25519_pubkey(
        K_activity,
        user_pubkey
    );
    access_grants.push(encrypted_key);
}
```

**Decryption (Client-Side):**
```rust
// User's wallet has private key
for grant in activity.access_grants {
    if let Ok(K_activity) = decrypt_with_wallet(grant, user_wallet) {
        // Got the key! Decrypt content
        let content = aes_256_gcm_decrypt(
            activity.encrypted_content,
            K_activity,
            activity.nonce
        );
        return content;
    }
}
// No valid grant found - user wasn't present
return None;
```

### Storage Optimization

**Light Protocol ZK Compression:**
- Instead of storing full timeline in one account (10MB limit)
- Store Merkle root (32 bytes) in account
- Actual activity data in cheap ledger space
- 5000x cheaper storage
- Still queryable and verifiable
- Can handle 100,000+ activities per camera

**Activity Entry Size:**
```
timestamp: 8 bytes
activity_type: 1 byte
encrypted_content: ~150 bytes (Pipe URL + metadata encrypted)
access_grants: ~64 bytes per user present
Total: ~200-300 bytes per activity
```

**Scalability:**
- 10,000 activities × 250 bytes = 2.5 MB
- With ZK Compression: Virtually unlimited
- Old activities can be archived to cheaper storage

---

## Implementation Plan

### Phase 1: Extend Checkout Instruction

**Modify existing check_out instruction:**
```rust
pub fn check_out_with_activities(
    ctx: Context<CheckOut>,
    activities: Vec<ActivityData>
) -> Result<()> {
    // Existing checkout logic (lines 38-106 in check_out.rs)
    let is_user_checkout = ctx.accounts.closer.key() == session.user;
    let is_expired = now > session.auto_checkout_at;

    require!(is_user_checkout || is_expired, Unauthorized);

    // NEW: Encrypt and commit activities
    for activity in activities {
        let activity_key = generate_random_key();
        let encrypted_content = aes_encrypt(
            &activity.data,
            &activity_key
        );

        let mut access_grants = vec![];
        for user in activity.users_present {
            access_grants.push(
                encrypt_to_pubkey(&activity_key, &user)
            );
        }

        ctx.accounts.camera.timeline.push(EncryptedActivity {
            timestamp: activity.timestamp,
            activity_type: activity.activity_type,
            encrypted_content,
            access_grants,
        });
    }

    // Existing: close session, emit events, etc.
    Ok(())
}
```

### Phase 2: Backend Activity Buffering

**Add session buffer table:**
```typescript
interface SessionBuffer {
    session_id: string;
    camera_id: string;
    user_pubkey: string;
    activities: Activity[];
    created_at: number;
}

interface Activity {
    type: string;
    timestamp: number;
    pipe_url: string;
    metadata: any;
}
```

**Modify activity recording:**
```typescript
// OLD: Immediate onchain transaction
await program.methods.recordActivity(...).rpc();

// NEW: Buffer in backend
await db.sessionBuffers.push({
    session_id,
    activity: {
        type: "photo",
        timestamp: Date.now(),
        pipe_url: pipeUrl,
        metadata: {...}
    }
});
```

### Phase 3: Auto-Checkout Bot

**Extend existing bot:**
```typescript
// Find expired sessions (existing logic)
const expiredSessions = await findExpiredSessions();

for (const session of expiredSessions) {
    // NEW: Fetch buffered activities
    const activities = await backend.getSessionActivities(session.id);

    // Call checkout with activities
    await program.methods.checkOutWithActivities(activities)
        .accounts({
            closer: botWallet.publicKey,
            session: session.publicKey,
            camera: session.camera,
            rentDestination: botWallet.publicKey  // Get rent reward
        })
        .rpc();

    // Clear buffer
    await backend.clearSessionActivities(session.id);
}
```

### Phase 4: Frontend Decryption

**Timeline query with client-side decryption:**
```typescript
async function getTimeline(cameraId: string, userWallet: Wallet) {
    // 1. Get user's sessions at this camera
    const userSessions = await fetchUserSessions(userWallet, cameraId);

    // 2. Fetch camera's timeline
    const timeline = await program.account.camera.fetch(cameraId);

    // 3. Filter and decrypt
    const decryptedActivities = [];

    for (const activity of timeline.encrypted_timeline) {
        // Check if timestamp overlaps with any user session
        const inUserTimeframe = userSessions.some(session =>
            activity.timestamp >= session.checkInTime &&
            activity.timestamp <= session.checkOutTime
        );

        if (!inUserTimeframe) continue;

        // Try to decrypt with user's wallet
        for (const grant of activity.access_grants) {
            try {
                const activityKey = await decryptWithWallet(
                    grant,
                    userWallet.privateKey
                );

                const content = await aesDecrypt(
                    activity.encrypted_content,
                    activityKey
                );

                decryptedActivities.push({
                    timestamp: activity.timestamp,
                    type: activity.activity_type,
                    ...content
                });

                break;  // Successfully decrypted
            } catch (e) {
                continue;  // Try next grant
            }
        }
    }

    return decryptedActivities.sort((a, b) => b.timestamp - a.timestamp);
}
```

### Phase 5: Shielded Sessions

**Add pseudonymous session accounts:**
```rust
pub struct ShieldedSession {
    pub session_id: [u8; 32],        // hash(user + camera + time)
    pub camera: Pubkey,
    pub check_in_time: i64,
    pub check_out_time: Option<i64>,
    pub encrypted_user: [u8; 32],     // encrypt(user, camera_key)
    pub bump: u8,
}
```

**Check-in creates shielded session:**
```typescript
const sessionId = sha256(userPubkey + cameraId + timestamp);
const encryptedUser = encrypt(userPubkey, cameraPublicKey);

await program.methods.checkInShielded(sessionId, encryptedUser)
    .rpc();
```

---

## Migration Strategy

### Phase 1: Parallel Operation (Weeks 1-4)
- Deploy new privacy-enabled instructions alongside existing
- Flag cameras as "privacy-enabled" or "legacy"
- New cameras default to privacy mode
- Existing cameras can opt-in

### Phase 2: User Migration (Weeks 5-8)
- Incentivize users to try privacy mode
- "Your next session will be private and cost 83% less"
- Monitor adoption metrics

### Phase 3: Deprecation (Week 9+)
- After 90% adoption, deprecate old `record_activity` instruction
- Historical data stays as-is (can't retroactively make private)
- Mark cutoff date: "Privacy mode activated [date]"

---

## Cost Analysis

### Current Model
```
Session with 10 photos:
- Check-in: 1 tx × 0.000005 SOL
- 10 photos: 10 tx × 0.000005 SOL
- Check-out: 1 tx × 0.000005 SOL
Total: 0.00006 SOL
```

### New Model
```
Session with 10 photos:
- Check-in: 1 tx × 0.000005 SOL
- Check-out (with bundle): 1 tx × 0.000005 SOL
Total: 0.00001 SOL
Savings: 83% reduction
```

**With ZK Compression:**
- Timeline storage: 5000x cheaper
- Even 100,000 activities feasible per camera

---

## Alternative: Arcium MPC (Future Enhancement)

If later you need stronger privacy guarantees (camera operator can't see activities), consider Arcium:

**Standard Crypto (Current Plan):**
- Jetson/Backend sees plaintext temporarily
- Encrypts to user wallets
- Simpler, cheaper

**Arcium MPC:**
- Activities encrypted before Jetson sees them
- MPC network does filtering/re-encryption
- No single party sees plaintext
- More complex, more expensive, but provably private

**Recommendation:** Start with standard crypto. Add Arcium later if needed for compliance/regulation.

---

## Open Questions

1. **Auto-checkout bot reliability:** Multiple bots? Fallback mechanisms?
2. **Access grant size:** Max users per activity before tx too large?
3. **Clock skew:** Handle timestamp differences between Jetson/Solana?
4. **Minimum overlap:** Require ≥5 min overlap to prevent edge cases?
5. **Timeline pagination:** How to efficiently query large timelines?

---

## Success Criteria

- ✅ 83% reduction in transaction costs
- ✅ Block explorers cannot map user → camera associations
- ✅ Users can decrypt timeline with only their wallet key
- ✅ System works even if backend dies
- ✅ Auto-checkout bot handles 99.9% of checkouts
- ✅ Timeline remains queryable at any scale

---

## Conclusion

This architecture transforms mmoment into a network of "memory boxes" where:
- Each camera is an entity with permanent onchain memory
- Users receive time-windowed view access based on physical presence
- Privacy enforced cryptographically using user wallet keys
- No backend dependency for decryption
- Lived social graph emerges from real IRL co-location

**The camera isn't surveilling you - you're receiving access to its memory of the time you shared its space.**

This is what decentralized social infrastructure should look like.
